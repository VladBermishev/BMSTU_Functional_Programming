(load "trace.scm")
(load "unit-test.scm")
(define (my-element? value collectable)
  (define (_iter values result)
    (if (or result (null? values))
        result
        (_iter (cdr values) (equal? (car values) value))))
  (_iter collectable #f))

(define-syntax is
  (syntax-rules (in)
    ((_ value in collectable)
     (my-element? value collectable))))

(define (filter collectable predicate?)
  (define (_iter values result)
    (if (null? values)
        result
        (if (predicate? (car values))
            (_iter (cdr values) result)
            (_iter (cdr values) (cons (car values) result)))))
  (reverse (_iter collectable '())))



(define (operation? value)
  (if (symbol? value)
      (is value in '(+ - / * expt exp quotient sin cos remainder modulo max min abs gcd lcm floor ceiling truncate round log))
      #f))
(define (variable? value)
  (if (symbol? value)
      (not (operation? value))
      #f))
(define (constant? value)
  (define (_iter lst result in_new_list)
    (if (list? lst)
        (if (null? lst)
            result
            (if (and (equal? (length lst) 1) (operation? (car lst)))
                #f
                (_iter (cdr lst) (and result (_iter (car lst) result (if (list? (car lst)) #t in_new_list))) #f)))
        (if (operation? lst)
            (and result in_new_list)
            (number? lst))))
  (if (symbol? value)
      #f
      (_iter value #t #t)))

(define (function? expression)
  (define (_iter expression result)
    (if (null? expression)
        result
        (if (list? expression)
            (if (list? (car expression))
                (_iter (cdr expression) (_iter (car expression) result))
                (if (variable? (car expression))
                    (if (not (is (car expression) in result))
                        (_iter (cdr expression) (cons (car expression) result))
                        (_iter (cdr expression) result))
                    (_iter (cdr expression) result)))
            result)))
  (<= (length (_iter expression '())) 1))

(define (power-of-variable? lst)
  (if (and (list? lst) (equal? (length lst) 3))
      (and (equal? (car lst) 'expt) (variable? (cadr lst)) (function? (caddr lst)))
      #f))
(define (variable-power-of-constant? lst)
  (if (and (list? lst) (>= (length lst) 2))
      (or
       (and (equal? (car lst) 'expt) (constant? (cadr lst)) (function? (caddr lst)))
       (and (equal? (car lst) 'exp) (function? (cadr lst))))
      #f))
(define (log-of-variable? lst)
  (if (and (list? lst) (equal? (length lst) 2))
      (and (equal? (car lst) 'log) (function? (cadr lst)))
      #f))
(define (sin-of-variable? lst)
  (if (and (list? lst) (equal? (length lst) 2))
      (and (equal? (car lst) 'sin) (function? (cadr lst)))
      #f))
(define (cos-of-variable? lst)
  (if (and (list? lst) (equal? (length lst) 2))
      (and (equal? (car lst) 'cos) (function? (cadr lst)))
      #f))
(define (sum-of-funcs? lst)
  (if (and (list? lst) (equal? (length lst) 3))
      (and (equal? (car lst) '+) (function? (cadr lst)) (function? (caddr lst)))
      #f))
(define (sub-of-funcs? lst)
  (if (and (list? lst) (equal? (length lst) 3))
      (and (equal? (car lst) '-) (function? (cadr lst)) (function? (caddr lst)))
      #f))
(define (mul-of-funcs? lst)
  (if (and (list? lst) (equal? (length lst) 3))
      (and (equal? (car lst) '*) (function? (cadr lst)) (function? (caddr lst)))
      #f))
(define (div-of-funcs? lst)
  (if (and (list? lst) (equal? (length lst) 3))
      (and (equal? (car lst) '/) (function? (cadr lst)) (function? (caddr lst)))
      #f))

(define (simplify expression)
  (define (_iter expression result)
    (if (list? expression)
        (if (null? expression)
            result
            (if (constant? (car expression))
                (_iter (cdr expression) (cons (eval (car expression) (interaction-environment)) result))
                (if (list? (car expression))
                    (_iter (cdr expression) (cons (reverse (_iter (car expression) '())) result))
                    (_iter (cdr expression) (cons (car expression) result)))))
        expression))
  (define (multiple-constants expr result buffer)
    (if (null? expr)
        (list * result (reverse buffer))
        (if (constant? (car expr))
            (multiple-constants (cdr expr) (* result (car expr)) buffer)
            (multiple-constants (cdr expr) result (cons (car expression) buffer)))))
  (define (simplify-rules expression)
    (cond
      ((not (list? expression)) expression)
      ((and (equal? (car expression) '*) (is 0 in expression)) 0)
      ((and (equal? (car expression) '*) (is 1 in expression)) (filter expression (lambda (x) (equal? x 1))))
      ((and (> (length expression) 2) (equal? (car expression) '/) (equal? (cadr expression) 0) 0))
      ((and (equal? (car expression) '+) (is 0 in expression)) (filter expression (lambda (x) (equal? x 0))))
      ((and (equal? (length expression) 2) (or (equal? (car expression) '+) (equal? (car expression) '*))) (cadr expression))
      ((and (equal? (length expression) 3) (equal? (car expression) 'expt) (equal? (cadr expression) 'x) (equal? (caddr expression) 1) 'x))
      (else expression)))
  (define (_simplify expression result)
    (if (null? expression)
        (simplify-rules result)
        (let vars ((expr (simplify-rules expression)))
          (if (list? expr)
              (if (list? (car expr))
                  (_simplify (cdr expr) (append result (list (_simplify (car expr) '()))))
                  (_simplify (cdr expr) (append result (list (car expr)))))
              expr))))
  (let vars ((result (_iter expression '())))
    (if (list? result)
        (_simplify (reverse result) '())
        result)))

(define (derivative expression)
  (define (derivative-rules expression)
  (cond
    ((constant? expression) 0)
    ((and (list? expression) (equal? (length expression) 1)) (derivative-rules (car expression)))
    ((and (list? expression) (equal? (length expression) 2) (equal? (car expression) '-)) (list '- (derivative-rules (cadr expression))))
    ((variable? expression) 1)
    ((power-of-variable? expression) (list '* (caddr expression) (derivative-rules (cadr expression)) (list 'expt (cadr expression) (list '- (caddr expression) 1))))
    ((variable-power-of-constant? expression) (list '* expression (if (equal? (length expression) 3)
                                                                      (derivative-rules (caddr expression))
                                                                      (derivative-rules (cadr expression)))
                                                    (if (equal? (length expression) 3)
                                                        (list 'log (cadr expression))
                                                        1)))
    ((log-of-variable? expression) (list '* (derivative-rules (cadr expression))
                                         (list '/ 1 (if (equal? (length expression) 3)
                                                        (list '* (cadr expression) (list 'log (caddr expression)))
                                                        (cadr expression)))))
    ((sin-of-variable? expression) (list '* (derivative-rules (cadr expression)) (list 'cos (cadr expression))))
    ((cos-of-variable? expression) (list '- (list '* (derivative-rules (cadr expression)) (list 'sin (cadr expression)))))
    ((sum-of-funcs? expression) (list '+ (derivative-rules (cadr expression)) (derivative-rules (caddr expression))))
    ((sub-of-funcs? expression) (list '- (derivative-rules (cadr expression)) (derivative-rules (caddr expression))))
    ((mul-of-funcs? expression) (list '+ (list '* (caddr expression) (derivative-rules (cadr expression)))
                                      (list '* (cadr expression) (derivative-rules (caddr expression)))))
    ((div-of-funcs? expression) (list '/ (list '- (list '* (caddr expression) (derivative-rules (cadr expression)))
                                               (list '* (cadr expression) (derivative-rules (caddr expression))))
                                      (list 'expt (caddr expression) 2)))
    (else expression)))
  (simplify (simplify (derivative-rules (simplify expression)))))

(define (derivative-rules expression)
  (cond
    ((constant? expression) 0)
    ((and (list? expression) (equal? (length expression) 1)) (derivative-rules (car expression)))
    ((and (list? expression) (equal? (length expression) 2) (equal? (car expression) '-)) (list '- (derivative-rules (cadr expression))))
    ((variable? expression) 1)
    ((power-of-variable? expression) (list '* (caddr expression) (derivative-rules (cadr expression)) (list 'expt (cadr expression) (list '- (caddr expression) 1))))
    ((variable-power-of-constant? expression) (list '* expression (if (equal? (length expression) 3)
                                                                      (derivative-rules (caddr expression))
                                                                      (derivative-rules (cadr expression)))
                                                    (if (equal? (length expression) 3)
                                                        (list 'log (cadr expression))
                                                        1)))
    ((log-of-variable? expression) (list '* (derivative-rules (cadr expression))
                                         (list '/ 1 (if (equal? (length expression) 3)
                                                        (list '* (cadr expression) (list 'log (caddr expression)))
                                                        (cadr expression)))))
    ((sin-of-variable? expression) (list '* (derivative-rules (cadr expression)) (list 'cos (cadr expression))))
    ((cos-of-variable? expression) (list '- (list '* (derivative-rules (cadr expression)) (list 'sin (cadr expression)))))
    ((sum-of-funcs? expression) (list '+ (derivative-rules (cadr expression)) (derivative-rules (caddr expression))))
    ((mul-of-funcs? expression) (list '+ (list '* (caddr expression) (derivative-rules (cadr expression)))
                                      (list '* (cadr expression) (derivative-rules (caddr expression)))))
    ((div-of-funcs? expression) (list '/ (list '- (list '* (caddr expression) (derivative-rules (cadr expression)))
                                               (list '* (cadr expression) (derivative-rules (caddr expression))))
                                      (list 'expt (caddr expression) 2)))
    (else expression)))
(define the-tests (list
                   (test (derivative '(2)) 0)
                   (test (derivative '2) 0)
                   (test (derivative 'x) 1)
                   (test (derivative '(- x)) '(- 1))
                   (test (derivative '(* 1 x)) 1)
                   (test (derivative '(- (* 4 x))) '(- 4))
                   (test (derivative '(* 10 x)) 10)
                   (test (derivative '(- (* 2 x) 3)) '(- 2 0))
                   (test (derivative '(expt x 10)) '(* 10 (expt x 9)))
                   (test (derivative '(* 2 (expt x 5))) '(* 2 (* 5 (expt x 4))))
                   (test (derivative '(expt x (- 2))) '(* -2 (expt x -3)))
                   (test (derivative '(expt 5 x)) '( * (expt 5 x) 1.6094379124341003))
                   (test (derivative '(cos x)) '(- (sin x)))
                   (test (derivative '(sin x)) '(cos x))
                   (test (derivative '(exp x)) '(exp x))
                   (test (derivative '(* 2 (exp x))) '(* 2 (exp x)))
                   (test (derivative '(* 2 (exp (* 2 x)))) '(* 2 (* (exp (* 2 x)) 2)))
                   (test (derivative '(log x)) '(/ 1 x))
                   (test (derivative '(* 3 (log x))) '(* 3 (/ 1 x)))
                   (test (derivative '(+ (expt x 3) (expt x 2))) '(+ (* 3 (expt x 2)) (* 2 x)))
                   (test (derivative '(- (* 2 (expt x 3)) (* 2 (expt x 2)))) '(- (* 2 (* 3 (expt x 2))) (* 2 (* 2 x))))
                   (test (derivative '(/ 3 x)) '(/ -3 (expt x 2)))
                   (test (derivative '(/ 3 (* 2 (expt x 2)))) '(/ (- 0 (* 3 (* 2 (* 2 x)))) (expt (* 2 (expt x 2)) 2)))
                   (test (derivative '(* 2 (* (sin x) (cos x)))) '(* 2 (+ (* (cos x) (cos x)) (* (sin x) (- (sin x))))))
                   (test (derivative '(sin (* 2 x))) '(* 2 (cos (* 2 x))))
                   (test (derivative '(cos (* 2 (expt x 2)))) '(- (* (* 2 (* 2 x)) (sin (* 2 (expt x 2))))))
                   (test (derivative '(sin (log (expt x 2)))) '(* (* (* 2 x) (/ 1 (expt x 2))) (cos (log (expt x 2)))))))
(run-tests the-tests)
  


